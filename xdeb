#!/bin/sh

# Directories and filenames
XDEB_PKGROOT="$(realpath "${XDEB_PKGROOT-${PWD}}")"
XDEB_DESTDIR="${XDEB_PKGROOT}/destdir"
XDEB_DATADIR="${XDEB_PKGROOT}/data"
XDEB_BINPKGS="${XDEB_PKGROOT}/binpkgs"
XDEB_SHLIBS="${XDEB_PKGROOT}/shlibs"

# Options
XDEB_OPT_DEPS=false
XDEB_OPT_SYNC=false
XDEB_OPT_QUIT=false
XDEB_OPT_EXTRACT=true
XDEB_OPT_CLEAN_DIR=false
XDEB_OPT_WARN_CONFLICT=true
XDEB_SUFFIX=""

log_message () {
	echo "$(tput bold)[$(tput setaf 6)i$(tput sgr0)$(tput bold)]$(tput sgr0) ${*}"
}

log_success () {
	echo "$(tput bold)[$(tput setaf 2)+$(tput sgr0)$(tput bold)]$(tput sgr0) ${*}"
}

log_failure () {
	echo "$(tput bold)[$(tput setaf 3)-$(tput sgr0)$(tput bold)]$(tput sgr0) ${*}"
}

log_critical () {
	echo "$(tput bold)[$(tput setaf 1)!$(tput sgr0)$(tput bold)]$(tput sgr0) ${*}"
}

# clean : Removes old package data, without removing any binpkgs
clean () {
	rm -rf "${XDEB_PKGROOT}"/control.tar.?z
	rm -rf "${XDEB_PKGROOT}"/data.tar.?z
	rm -rf "${XDEB_PKGROOT}"/debian-binary

	rm -rf "${XDEB_BINPKGS}"/.xbps-pkg-*

	rm -rf "${XDEB_DATADIR}"
	rm -rf "${XDEB_DESTDIR}"
}

# clean_repodata : Removes the repodata file. Needed to rebuild a package with the same version
clean_repodata () {
	rm -rf "${XDEB_BINPKGS}"/*-repodata
}

# clean_all : Remove everything, this script created
clean_all () {
	clean
	clean_repodata
	rm -rf "${XDEB_BINPKGS}"
	rm -rf "${XDEB_SHLIBS}"
}

autodeps () {
	find "${XDEB_DESTDIR}" -type f | while read -r f; do
		[ "$(head -c 4 "${f}")" = "$(printf "\177ELF")" ] || continue

		ldd "${f}" 2> /dev/null | grep -Po "^[ \t]*\K[^\/]*(?= \=\>)" | while read -r lib; do
			echo "${lib}"
		done
	done | sort -u | while read -r lib; do
		escaped="$(printf '%s' "${lib}" | sed 's/[^A-Za-z0-9]/\\\0/g')"
		dependency="$(grep -m1 -Po "^${escaped} \K[^ ]*(?=-)" "${XDEB_SHLIBS}" | tr -d '\n')"

		if [ -z "${dependency}" ]; then
			log_failure "Unable to find dependency for ${lib}" >&2
			continue
		fi

		printf "%s " "${dependency}${XDEB_SUFFIX}>=0"
	done
}

check_command() {
	command -v "$1" > /dev/null 2>&1 && return 0

	log_critical "Dependency '${1}' not found"
	exit 1
}

help () {
	cat << EOF
usage: xdeb [-S] [-d] [-Sd] [--deps] ... FILE
  -d                       # Automatic dependencies
  -S                       # Sync runtime dependency file
  -h                       # Show this page
  -c                       # Clean everything except shlibs and binpkgs
  -r                       # Clean repodata (Use when rebuilding a package)
  -q                       # Don't build the package at all
  -C                       # Clean all files
  -b                       # No extract, just build files in destdir
  -e                       # Remove empty directories
  -m                       # Add the -32bit suffix
  -i                       # Ignore file conflicts
  --deps                   # Add manual dependencies
  --arch                   # Add an arch for the package to run on

example:
  xdeb -Cq                 # Remove all files and quit
  xdeb -Sd FILE            # Sync depdendency list and create package
  xdeb --deps 'ar>0' FILE  # Add ar as a manual dependency and create package
EOF
}

check_command ar
check_command tar
check_command curl
check_command xbps-rindex
check_command xbps-create

mkdir -p "${XDEB_PKGROOT}"

i=0
for arg in "${@}"; do
	i=$((i + 1))
	# Does the current argument start with a dash?
	rest="${arg#?}"
	first="${arg%"${rest}"}"
	tmp="${rest}"
	if [ "${first}" != "-" ]; then break; fi
	
	case "${arg}" in
		--deps)
			XDEB_DEPENDENCIES="$(eval echo "\${$((i + 1))}")"
			continue;;
		--arch)
			archs="$(eval echo "\${$((i + 1))}")"
			continue;;
		*);;
	esac

	while [ -n "${tmp}" ]; do
		rest="${tmp#?}"
		first="${tmp%"${rest}"}"
		
		case "${first}" in
			S)
				XDEB_OPT_SYNC=true;;
			d)
				XDEB_OPT_DEPS=true;;
			h)
				help
				exit 0;;
			c)
				clean;;
			C)
				clean_all;;
			r)
				clean_repodata;;
			q)
				XDEB_OPT_QUIT=true;;
			b)
				XDEB_OPT_EXTRACT=false;;
			e)
				XDEB_OPT_CLEAN_DIR=true;;
			m)
				XDEB_SUFFIX="-32bit";;
			i)
				XDEB_OPT_WARN_CONFLICT=false;;
			*)
				log_failure "Unknown option -${first}"
				help
				exit 1;;
		esac

		tmp="${rest}"
	done
done

if [ "${XDEB_OPT_SYNC}" = true ]; then
	curl \
		-s "https://raw.githubusercontent.com/void-linux/void-packages/master/common/shlibs" \
		-o "${XDEB_SHLIBS}"
	log_success "Synced shlibs"
fi

if { test "${XDEB_OPT_DEPS}" = true && test ! -r "${XDEB_SHLIBS}"; }; then
	log_failure "Sync atleast once, before using the depencency option"
	exit 1
fi

# Quit after parsing every argument argument
if [ "${XDEB_OPT_QUIT}" = true ]; then
	log_message "Quitting before building"
	exit 0;
fi

# find last argument
for XDEB_BASEPKG in "$@"; do true; done

if [ "${XDEB_OPT_EXTRACT}" = true ]; then
	# Does the filename end with .deb? Is the file readable?
	echo "${XDEB_BASEPKG}" | grep -q "\.deb$" || [ -r "${XDEB_BASEPKG}" ] || {
		log_failure "Last argument has to point to an existing deb package"
		exit 1
	}

	clean
	mkdir -p "${XDEB_BINPKGS}"
	mkdir -p "${XDEB_DATADIR}"
	mkdir -p "${XDEB_DESTDIR}"

	# Extract the packages, every operation has to succeed
	ar -xf "${XDEB_BASEPKG}" --output "${XDEB_PKGROOT}" &&
	tar -xf "${XDEB_PKGROOT}"/control.tar.?z -C "${XDEB_DATADIR}" &&
	tar -xf "${XDEB_PKGROOT}"/data.tar.?z -C "${XDEB_DESTDIR}" || {
		log_failure "Not a valid deb file"
		exit 1
	}

	log_success "Extracted files"
fi

# The variable names are the same as in the regular xbps-src package build
pkgname=$(grep -Po "Package:[ \t]*\K.*" "${XDEB_DATADIR}/control")
version=$(grep -Po "Version:[ \t]*\K.*" "${XDEB_DATADIR}/control")
license=$(grep -Po "License:[ \t]*\K.*" "${XDEB_DATADIR}/control")
if [ -z "${archs}" ]; then
	archs=$(grep -Po "Architecture:[ \t]*\K.*" "${XDEB_DATADIR}/control")
fi
maintainer=$(grep -Po "Maintainer:[ \t]*\K.*" "${XDEB_DATADIR}/control")
short_desc=$(grep -Po "Description:[ \t]*\K.*" "${XDEB_DATADIR}/control")
long_desc=$(grep -Pzo "Description:[ \t\n]*\K.*" "${XDEB_DATADIR}/control" | tr '\0' '\n')

# It seems that debian packages don't have to provide a short_desc (XMind-ZEN didn't do it)
if [ -z "${short_desc}" ]; then
	log_message "short_desc not found, using long_desc instead"
	short_desc="${long_desc}"
fi

version=$(echo "${version}" | grep -Po "^(\d|\.)*")
case "${archs}" in
	amd64) archs="x86_64";;
	i386) archs="i686";;
	all) archs="noarch";;
	*);;
esac

if [ "${XDEB_OPT_DEPS}" = true ]; then
	XDEB_DEPENDENCIES="${XDEB_DEPENDENCIES} $(autodeps)"
fi

if [ -n "${XDEB_DEPENDENCIES}" ]; then
	log_success "Resolved dependencies (${XDEB_DEPENDENCIES})"
fi

log_success "'Parsed' deb control file"

find "${XDEB_DESTDIR}" | {
	rc=0

	while read -r file; do
		# Remove empty directories
		[ "${XDEB_OPT_CLEAN_DIR}" = true ] && [ -z "$(ls -A "${file}")" ] && {
			rm -rf "${file}"
			log_success "Removed empty directory ${file}"
			continue
		}

		# Check for conflicts
		[ "${XDEB_OPT_WARN_CONFLICT}" != true ] && continue

		file_root="${file#${XDEB_DESTDIR}*}"
		[ ! -e "${file_root}" ] || { [ -d "${file_root}" ] && [ -d "${file}" ]; } && continue
		log_critical "Conflict: $(tput bold)${file}$(tput sgr0)"
		rc=1
	done

	return "${rc}"
} || log_failure "Unless updating, consider removing conflicting files and rebuild with \"-rb\""

cd "${XDEB_BINPKGS}" || exit
xbps-create -q -A "${archs}" -n "${pkgname}${XDEB_SUFFIX}-${version}_1" -m "${maintainer}" -s "${short_desc}" -S "${long_desc}" -l "${license}" -D "${XDEB_DEPENDENCIES}" "${XDEB_DESTDIR}"
log_success "Created Package"
xbps-rindex -a ./*.xbps
log_success "Registered package"
